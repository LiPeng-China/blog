import{_ as a,X as e,Y as i,Z as n}from"./framework-bf6cbb95.js";const l={},d=n(`<h2 id="一、计算机网络" tabindex="-1"><a class="header-anchor" href="#一、计算机网络" aria-hidden="true">#</a> 一、计算机网络</h2><h3 id="_1、tcp-怎么保证可靠性-与-udp-的区别" tabindex="-1"><a class="header-anchor" href="#_1、tcp-怎么保证可靠性-与-udp-的区别" aria-hidden="true">#</a> 1、TCP 怎么保证可靠性，与 UDP 的区别？</h3><ul><li>建立连接：通过三次握手建立连接，保证连接实体真实存在</li><li>序号机制：保证数据按序、完整到达</li><li>数据校验：TCP 报文头提供校验和，校验报文是否损坏</li><li>超时重传：如果发送方一直接收不到应答，等待一段时间后会重传</li><li>流量控制：免发送方的数据填满接收方的缓存；当接收方来不及处理发送发的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失；</li><li>拥塞控制：避免发送方的数据填满网络；拥塞控制的主要算法：慢启动（&lt;slow start threshold）、拥塞避免（&gt;slow start threshold）、快速重传三种机制。</li></ul><p>TCP：是面向连接的、可靠的数据传输服务</p><p>UDP：是面向非连接的、不可靠得到数据传输服务</p><h3 id="_2、tcp-的拥塞避免算法" tabindex="-1"><a class="header-anchor" href="#_2、tcp-的拥塞避免算法" aria-hidden="true">#</a> 2、TCP 的拥塞避免算法？</h3><p>TODO</p><h3 id="_3、https-怎么保证可靠性" tabindex="-1"><a class="header-anchor" href="#_3、https-怎么保证可靠性" aria-hidden="true">#</a> 3、HTTPS 怎么保证可靠性？</h3><p>TODO</p><h3 id="_4、tls-四次握手具体实现" tabindex="-1"><a class="header-anchor" href="#_4、tls-四次握手具体实现" aria-hidden="true">#</a> 4、TLS 四次握手具体实现？</h3><p>TODO</p><h3 id="_5、tcp-的粘包是什么原因导致的" tabindex="-1"><a class="header-anchor" href="#_5、tcp-的粘包是什么原因导致的" aria-hidden="true">#</a> 5、TCP 的粘包是什么原因导致的？</h3><ul><li>为了高效传输数据，发送端采用优化算法（Nagle），将多次间隔较短、数据量较小的数据，合并成一个大数据包，进行封包发送给接收端。</li><li>接收端将接收到的数据包保存在接收缓存里，应用程序主动从缓存中读取数据，当保存速度大于读取速度时，应用程序就会读取到粘包。</li></ul><h3 id="_6、tcp-的拆包-怎么解决粘包" tabindex="-1"><a class="header-anchor" href="#_6、tcp-的拆包-怎么解决粘包" aria-hidden="true">#</a> 6、TCP 的拆包（怎么解决粘包）？</h3><ul><li>固定消息长度</li><li>特殊字符作为边界（FTP、SMTP）</li><li>自定义消息结构（HTTP）</li></ul><p><strong>HTTP 如何解决粘包问题：</strong></p><ul><li><p>特殊字符</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>请求（响应）行 <span class="token punctuation">\\</span>r<span class="token punctuation">\\</span>n
请求（响应）头 <span class="token punctuation">\\</span>r<span class="token punctuation">\\</span>n
<span class="token punctuation">\\</span>r<span class="token punctuation">\\</span>n（CRLF）
数据
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>自定义消息格式</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>Header:
	Content-Length: <span class="token number">1966</span>
	Content-Type: image/x-icon
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="_7、www-baidu-com-的访问流程" tabindex="-1"><a class="header-anchor" href="#_7、www-baidu-com-的访问流程" aria-hidden="true">#</a> 7、<code>www.baidu.com</code> 的访问流程？</h3><p>TODO</p><h3 id="_8、tcp-的三次握手-为什么是三次" tabindex="-1"><a class="header-anchor" href="#_8、tcp-的三次握手-为什么是三次" aria-hidden="true">#</a> 8、TCP 的三次握手？为什么是三次？</h3><p>TODO</p><h3 id="_9、tcp-的四次挥手-可以合并成三次吗" tabindex="-1"><a class="header-anchor" href="#_9、tcp-的四次挥手-可以合并成三次吗" aria-hidden="true">#</a> 9、TCP 的四次挥手？可以合并成三次吗？</h3><p>TODO</p><h2 id="二、操作系统" tabindex="-1"><a class="header-anchor" href="#二、操作系统" aria-hidden="true">#</a> 二、操作系统</h2><h3 id="_1、线程与进程的区别" tabindex="-1"><a class="header-anchor" href="#_1、线程与进程的区别" aria-hidden="true">#</a> 1、线程与进程的区别？</h3><p>进程：是操作系统资源分配的最小单位；进程之间相互独立；</p><p>线程：程序运行的最小单位，相当于轻量级进程；更小的上下文切换、实现并行（多核）、并发；同一个进程下的多个线程可以共享进程的资源。</p><h3 id="_2、进程怎么通信-线程怎么通信" tabindex="-1"><a class="header-anchor" href="#_2、进程怎么通信-线程怎么通信" aria-hidden="true">#</a> 2、进程怎么通信？线程怎么通信？</h3><p>进程通信：</p><ul><li>管道（匿名、有名 Pipes）</li><li>信号（Signal）</li><li>消息队列</li><li>信号量（Semaphore）</li><li>共享内存（Shared memory）</li><li>套接字（Socket）</li></ul><p>线程通信：</p><ul><li>互斥锁（Mutex）</li><li>读写锁（Read-Write Lock）</li><li>信号量（Semaphore）</li><li>屏障（CyclicBarrier）</li><li>事件（notify / wait）</li></ul><h3 id="_3、死锁的定义-怎么避免-怎么预防" tabindex="-1"><a class="header-anchor" href="#_3、死锁的定义-怎么避免-怎么预防" aria-hidden="true">#</a> 3、死锁的定义？怎么避免？怎么预防？</h3><p>死锁的四个必要条件：互斥、持有且等待、不可抢占、循环等待</p><p>TODO</p>`,35),r=[d];function s(t,h){return e(),i("div",null,r)}const p=a(l,[["render",s],["__file","408基础.html.vue"]]);export{p as default};
